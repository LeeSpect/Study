# 인터페이스는 왜 필요한가?
다음은 어떤 동물원 사육사가 하는 일이다.
```
난 동물원의 사육사이다.
육식동물이 들어오면 난 먹이를 던져준다.
호랑이가 오면 사과를 던져준다.
사자가 오면 바나나를 던져준다.
```
이런 케이스를 코드로 담아보자. 다음과 같이 Animal, Tiger, Lion, Zookeeper 클래스를 작성하자.
```java
class Animal {
    String name;
    
    void setName(String name) {
        this.name = name;
    }
}

class Tiger extends Animal {
}

class Lion extends Animal {
}

class ZooKeeper {
    void feed(Tiger tiger) {   // 호랑이가 오면 사과를 던져 준다.
        System.out.println("feed apple");
    }
    
    void feed(Lion lion) {   // 사자가 오면 바나나를 던져 준다.
        System.out.println("feed banana");
    }
}

public class Sample {
    public static void main(String[] args) {
        ZooKeeper zooKeeper = new ZooKeeper();
        Tiger tiger = new Tiger();
        Lion lion = new Lion();
        zooKeeper.feed(tiger);   // feed apple 출력
        zooKeeper.feed(lion);   // feed banana 출력
    }
}
```

이전 챕터에서 보았던 Dog 클래스와 마찬가지로 Animal을 상속한 Tiger와 Lion이 등장했다. 그리고 사육사 클래스인 ZooKeeper 클래스를 위처럼 정의 하였다. ZooKeeper 클래스는 호랑이가 왔을 때, 사자가 왔을 때 각각 다른 feed 메소드가 호출된다.

※ ZooKeeper클래스의 feed메소드처럼 입력값의 자료형 타입이 다를 경우(위에서는 Tiger, Lion으로 서로 다르다)
메소드 명을 동일하게(여기서는 메소드명이 feed로 동일하다) 사용할 수 있다. 이런 것을 메소드 오버로딩(Method overloading)이라고 한다.

동물원에 호랑이와 사자뿐이라면 ZooKeeper 클래스는 더이상 할일이 없겠지만 악어, 표범등이 계속 추가된다면 ZooKeeper는 육식동물이 추가될 때마다 매번 같은 feed 메소드를 추가해야 한다.

이런 어려움을 극복하기 위해서는 인터페이스의 도움이 필요하다.

# 인터페이스 작성하기
다음과 같이 코드 상단에 육식동물(Predator) 인터페이스를 추가하자.
```java
interface Predator {
}

class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

(... 생략 ...)
```
위 코드와 같이 인터페이스는 class가 아닌 **interface**라는 키워드를 이용하여 작성한다.

※ 인터페이스는 클래스와 마찬가지로 Predator.java와 같은 단독 파일로 저장하는 것이 일반적인 방법이다.
여기서는 설명의 편의를 위해 Sample.java 파일의 최상단에 작성하였다.

그리고 Tiger, Lion 클래스는 작성한 인터페이스를 구현(Implements)하도록 수정하자.

```java
(... 생략 ...)

class Tiger extends Animal implements Predator {
}

class Lion extends Animal implements Predator {
}

(... 생략 ...)
```

인터페이스 구현은 위와같이 **implements**라는 키워드를 사용한다.

출처: https://wikidocs.net/217
